"13:43:39, 14 czerwca 2015: Compressed sources"!

"13:43:42, 14 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

InstallationSessionManager removeFromSystem!

"13:43:43, 14 czerwca 2015: Image saved"!

Object subclass: #ContractBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ContractBuilder guid: (GUID fromString: '{0198A206-47FA-4D11-9E67-939A143528C7}')!
ContractBuilder comment: ''!
!ContractBuilder categoriesForClass!Unclassified! !
ProtoObject subclass: #Instrument
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Instrument guid: (GUID fromString: '{EE67588F-9932-4A26-84ED-DCFBFB23B286}')!
Instrument comment: ''!
!Instrument categoriesForClass!Unclassified! !
Error subclass: #ContractViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ContractViolation guid: (GUID fromString: '{B8E71392-E924-4A22-B9ED-9FBC0ACC1782}')!
ContractViolation comment: ''!
!ContractViolation categoriesForClass!Unclassified! !
Error subclass: #ContractViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"14:38:40, 14 czerwca 2015: Image saved"!

"14:40:25, 14 czerwca 2015: Image saved"!

"19:21:27, 16 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #CBClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
CBClass guid: (GUID fromString: '{AA5CF289-B320-4A84-93E6-5B66093399B4}')!
CBClass comment: ''!
!CBClass categoriesForClass!Unclassified! !
Object subclass: #CBClass
	instanceVariableNames: 'c'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #CBClass
	instanceVariableNames: 'c'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ContractBuilder methodsFor!
class: cls
	|cbc|
	cbc := CBClass new;
	cbc c: cls;
	cbc.! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
class: cls
	|cbc|
	cbc := CBClass new.
	cbc c: cls.
	^ cbc.! !
!ContractBuilder categoriesFor: #class:!public! !

!

!

!

cbc := CBClass new.!

cbc.!

Object subclass: #CBClass
	instanceVariableNames: 'c'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
c: cls
	c := cls! !
!CBClass categoriesFor: #c:!public! !

!CBClass methodsFor!
c: cls
	c := cls! !
!CBClass categoriesFor: #c:!public! !

!ClassBuilder methodsFor!
class: cls
	|cbc|
	cbc := CBClass new.
	cbc c: cls.
	^cbc.! !
!ClassBuilder categoriesFor: #class:!public! !

!

cb := ClassBuilder new!

cb class: ClassBuilder!

"21:16:08, 16 czerwca 2015: Image saved"!

"18:05:28, 17 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

"20:06:12, 17 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!
Object subclass: #ClassBuilder
	instanceVariableNames: 'currentClass className instanceVariables superclass instanceSpec classVariables sharedPools comment flags categories cbcDict'
	classVariableNames: 'FixedInitialLayout FixedLayout IgnoreInstsMask RecompileMask Unsubclassable'
	poolDictionaries: '_BehaviorMasks'
	classInstanceVariableNames: ''!

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^ (self new)
	cbcDict: (Dictionary new);
	yourself.! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(self superclass) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(self new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(self new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(self new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder methodsFor!
initialize
	"Private - Initialize the instance."

	instanceSpec := 0.
	self beFixed.
	flags := 0.
	cbcDict := Dictionary new! !
!ClassBuilder categoriesFor: #initialize!initializing!private! !

d := Dictionary new;!

d at: 1!

d at: 1 ifAbsent: [d at: 1 put: 'a']!

d at: 1 ifAbsent: [d at: 1 put: 1]a DevelopmentSessionManager!

d at: 1 ifAbsent: [d at: 1 put: 1]!

d at: 1 ifAbsent: []!

d at: 1 ifAbsent: [];!

d at: 1 ifAbsent: [^d];Dictionary!

d at: 1 ifAbsent: [d];Dictionary!

d at: 1 ifAbsent: [d.]!

d at: 1 ifAbsent: [d;]!

d at: 1 ifAbsent: [:dict | dict at: 1 put: 1]!

d at: 1 ifAbsent: [:dict | dict at: 1 put: 1, dict]a DevelopmentSessionManager!

d at: 1 ifAbsent: ([:dict | dict at: 1 put: 1, dict])a DevelopmentSessionManager!

d at: 1 ifAbsent: [:dict | dict]a DevelopmentSessionManager!

d at: 1 ifAbsent: [:dict | dict]!

d at: 1!

d at: 1 put: 1!

d at: 1 put: 1.!

|d|!

d := Dictionary new;!

d at: 1 put: 1!

a := Dictionary new!

a at: 1 put: 1!

a!

a!

d at: 1 put: 1!

d := Dictionary new;Dictionary
d at: 1 put: 1!

d := Dictionary new;!

d at: 1 put: 1!

d := Dictionary new!

d at: 1 put: 1!

d at: 1 ifAbsent: [d at: 1 put: 1]!

d at: 1!

d := Dictionary new!

d at: 1 ifAbsent: [d at: 1 put: 1]!

d at: 2!

d at: 2 ifAbsent: [d at: 2 put: 2]!

!ClassBuilder methodsFor!
class: cls
	cbcDict at: cls ifAbsent: [cbcDict at: cls put: (CBClass new)]! !
!ClassBuilder categoriesFor: #class:!public! !

!ClassBuilder methodsFor!
class: cls
	cbcDict at: cls ifAbsent: [cbcDict at: cls put: ((CBClass new) c: cls)]! !
!ClassBuilder categoriesFor: #class:!public! !

cb := ClassBuilder new!

cb := ClassBuilder new!

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(superclass new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(superclass new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

cb := ClassBuilder new!

cb class: ClassBuilder!

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^super new initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

cb := ClassBuilder new!

cb class: ClassBuilder!

"20:54:38, 17 czerwca 2015: Image saved"!

"09:25:53, 18 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!
Object subclass: #ClassBuilder
	instanceVariableNames: 'currentClass className instanceVariables superclass instanceSpec classVariables sharedPools comment flags categories'
	classVariableNames: 'FixedInitialLayout FixedLayout IgnoreInstsMask RecompileMask Unsubclassable'
	poolDictionaries: '_BehaviorMasks'
	classInstanceVariableNames: ''!

Object subclass: #ContractBuilder
	instanceVariableNames: 'cbcDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #ContractBuilder
	instanceVariableNames: 'cbcDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #ContractBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #ContractBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"21:14:40, 18 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #ContractBuilder
	instanceVariableNames: 'cbcDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ContractBuilder methodsFor!
class: cls
	cbcDict at: cls ifAbsent: [cbcDict at: cls put: ((CBClass new) c: cls)]! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
initialize
	cbcDict := Dictionary new! !
!ContractBuilder categoriesFor: #initialize!public! !

!ContractBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^super new initialize! !
!ContractBuilder class categoriesFor: #new!public! !

cb := ContractBuilder new!

cb class: Context!

!ContractBuilder methodsFor!
class: cls
	^(cbcDict at: cls ifAbsent: [cbcDict at: cls put: ((CBClass new) c: cls)])! !
!ContractBuilder categoriesFor: #class:!public! !

cb class: Context!

!ClassBuilder methodsFor!
class: aClass
	"Private - Set the currentClass inst var to the class to be modified, aClass."

	currentClass := aClass.
	self instanceSpec: aClass instanceSpec.! !
!ClassBuilder categoriesFor: #class:!public! !

!ClassBuilder methodsFor!
initialize
	"Private - Initialize the instance."

	instanceSpec := 0.
	self beFixed.
	flags := 0.! !
!ClassBuilder categoriesFor: #initialize!initializing!private! !

Object subclass: #ClassBuilder
	instanceVariableNames: 'currentClass className instanceVariables superclass instanceSpec classVariables sharedPools comment flags categories'
	classVariableNames: 'FixedInitialLayout FixedLayout IgnoreInstsMask RecompileMask Unsubclassable'
	poolDictionaries: '_BehaviorMasks'
	classInstanceVariableNames: ''!

cb := ClassBuilder new!

cb := ContractBuilder new!

"21:22:04, 18 czerwca 2015: Image saved"!

"22:04:02, 19 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #CBClass
	instanceVariableNames: 'c invariantSet methodSet'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass class methodsFor!
new
	"Answer a new initialized instance."
	^super new initialize! !
!CBClass class categoriesFor: #new!public! !

!CBClass methodsFor!
initialize
	invariantSet := Set new.
	methodSet := Set new.! !
!CBClass categoriesFor: #initialize!public! !

cb := ContractBuilder new!

cb class: ContractBuilder!

!CBClass methodsFor!
addInvariant: inv
	invariantSet add: inv! !
!CBClass categoriesFor: #addInvariant:!public! !

cb := ContractBuilder new!

o := cb class: ContractBuilder!

o addInvariant: [:cls | ^true]!

!CBClass methodsFor!
removeInvariant: inv
	invariantSet remove: inv! !
!CBClass categoriesFor: #removeInvariant:!public! !

CBClass subclass: #CBMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
CBMethod guid: (GUID fromString: '{A0B100F8-85ED-443D-B563-1BD230FD1FA7}')!
CBMethod comment: ''!
!CBMethod categoriesForClass!Unclassified! !
CBClass subclass: #Object
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #CBMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
method: meth
	^(CBMethod new)! !
!CBClass categoriesFor: #method:!public! !

Object subclass: #CBClass
	instanceVariableNames: 'c invariantSet methodDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
initialize
	invariantSet := Set new.
	methodDict := Dictionary new.! !
!CBClass categoriesFor: #initialize!public! !

!CBClass methodsFor!
method: meth
	^(methodDict at: meth ifAbsent: [methodDict at: meth put: (CBMethod new)])! !
!CBClass categoriesFor: #method:!public! !

"22:20:00, 19 czerwca 2015: Image saved"!

"15:33:24, 20 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

"15:33:51, 20 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #CBMethod
	instanceVariableNames: 'preSet postSet'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBMethod class methodsFor!
new
	^self initialize! !
!CBMethod class categoriesFor: #new!public! !

!CBMethod methodsFor!
initialize
	preSet = Set new.
	postSet = Set new.! !
!CBMethod categoriesFor: #initialize!public! !

!CBMethod class methodsFor!
new
	^super initialize! !
!CBMethod class categoriesFor: #new!public! !

!CBMethod class methodsFor!
new
	^super new initialize! !
!CBMethod class categoriesFor: #new!public! !

cb := ContractBuilder new!

o := cb class: ContractBuilder!

o method: #class!

!CBMethod methodsFor!
addPrecondition: cond
	preSet add: cond! !
!CBMethod categoriesFor: #addPrecondition:!public! !

!CBMethod methodsFor!
removePrecondition: cond
	preSet remove: cond! !
!CBMethod categoriesFor: #removePrecondition:!public! !

!CBMethod methodsFor!
addPostcondition: cond
	postSet add: cond! !
!CBMethod categoriesFor: #addPostcondition:!public! !

!CBMethod methodsFor!
removePostcondition: cond
	postSet remove: cond! !
!CBMethod categoriesFor: #removePostcondition:!public! !

m := o method: #class!

m addPrecondition: 1!

!CBMethod methodsFor!
initialize
	preSet = Set new,
	postSet = Set new! !
!CBMethod categoriesFor: #initialize!public! !

!CBMethod methodsFor!
initialize
	preSet = Set new,
	postSet = Set new! !
!CBMethod categoriesFor: #initialize!public! !

m := o method: #class!

m addPrecondition: 1!

m addPrecondition: 1.!

cb := ContractBuilder new.
o := cb class: ContractBuilder.
m := o method: #class.
m addPrecondition: 1.!

cb := ContractBuilder new.
o := cb class: ContractBuilder.
m := o method: #class.
m addPrecondition: 1.!

Object subclass: #CBMethod
	instanceVariableNames: 'meth preSet postSet'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBMethod methodsFor!
method: aMeth
	! !
!CBMethod categoriesFor: #method:!public! !

!CBMethod methodsFor!
method: aMeth
	meth := aMeth! !
!CBMethod categoriesFor: #method:!public! !

!CBMethod methodsFor!
method: aMeth
	meth := aMeth! !
!CBMethod categoriesFor: #method:!public! !

!CBClass methodsFor!
method: meth
	^(methodDict at: meth ifAbsent: [methodDict at: meth put: ((CBMethod new) method: meth)])! !
!CBClass categoriesFor: #method:!public! !

!CBClass methodsFor!
method: meth
	^(methodDict at: meth ifAbsent: [methodDict at: meth put: ((CBMethod new) method: meth)])! !
!CBClass categoriesFor: #method:!public! !

!CBMethod methodsFor!
initialize
	preSet := Set new.
	postSet := Set new! !
!CBMethod categoriesFor: #initialize!public! !

m := o method: #class.!

m addPrecondition: 1.!

!CBMethod methodsFor!
method
	^meth! !
!CBMethod categoriesFor: #method!public! !

CBMethod removeSelector: #method ifAbsent: []!

!CBMethod methodsFor!
method: aMeth
	meth := aMeth! !
!CBMethod categoriesFor: #method:!public! !

"16:01:08, 20 czerwca 2015: Image saved"!

"16:01:11, 20 czerwca 2015: Image saved"!

"16:01:18, 20 czerwca 2015: Image saved"!

!ContractBuilder methodsFor!
contractFor: obj
	|cls|
	cls := obj class.
	
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new! !
!CBMethod categoriesFor: #sum:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.

	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBMethod methodsFor!
preConditions
	^preSet! !
!CBMethod categoriesFor: #preConditions!public! !

!CBMethod methodsFor!
postConditions
	^postSet! !
!CBMethod categoriesFor: #postConditions!public! !

!CBMethod methodsFor!
preConditions: conditions
	preSet := conditions! !
!CBMethod categoriesFor: #preConditions:!public! !

!CBMethod methodsFor!
postConditions: conditions
	postSet := conditions! !
!CBMethod categoriesFor: #postConditions:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.
	res preConditions: (self preConditions + other preConditions).
	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.
	res preConditions: (self preConditions + other preConditions).
	res postConditions: (self postConditions + other postConditions).
	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.
	res preConditions: (self preConditions + other preConditions).
	res postConditions: (self postConditions + other postConditions).
	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBClass methodsFor!
methods: meths
	methodDict := meths.! !
!CBClass categoriesFor: #methods:!public! !

!CBClass methodsFor!
methods: meths
	methodDict := meths! !
!CBClass categoriesFor: #methods:!public! !

!CBClass methodsFor!
methods: meths
	methodDict := meths.! !
!CBClass categoriesFor: #methods:!public! !

!CBClass methodsFor!
methods
	^methodDict! !
!CBClass categoriesFor: #methods!public! !

!CBClass methodsFor!
sum: other
	|res|
	res := CBClass new.
	
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum|
	res := CBClass new.

	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	commonKeys do: [:key | mSum at: key put: (methodDict at: key sum: other methods at: key)].
	res methods: mSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

cb := ContractBuilder new.!

o := cb class: ContractBuilder.!

m := o method: #class!

m addPrecondition: 1!

!CBClass methodsFor!
invariants
	^invariantSet! !
!CBClass categoriesFor: #invariants!public! !

!CBClass methodsFor!
invariants: invs
	invariantSet := invs.! !
!CBClass categoriesFor: #invariants:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: invariantSet + other invariants.
	^res! !
!CBClass categoriesFor: #sum:!public! !

"16:55:03, 20 czerwca 2015: Image saved"!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res|
	cls := obj class.
	
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

1 !!= 2!

1 \= 2!

1 = 2!

1 = 2 negated!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) class: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [] ]
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) class: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [] ].
	b b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) class: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

cb := ContractBuilder new.
o := cb class: ContractBuilder.
o addInvariant: [:q | q x notNil].
cb class: ContractBuilder!

cb class: ContractBuilder!

cb := ContractBuilder new.
o := cb class: 'wosiaczek'.
o addInvariant: [:q | q x notNil].
cb class: 'wosiaczek'!

cb class: 'wosiaczek'!

chuj := cb class: 'wosiaczek'.!

chuj!

cb := ContractBuilder new.
o := cb class: 'wosiaczek'.
o addInvariant: [:q | q x notNil].
chuj := cb class: 'wosiaczek'.
chuj!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) class: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls class = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  ((cls class) = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  ((cls class) = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  ((cls class) = #Object) not ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.
	res preConditions: (self preConditions union: (other preConditions)).
	res postConditions: (self postConditions union: (other postConditions)).
	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = #Object) not ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = #Object) not ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [CBClass new]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = Object) not ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [CBClass new]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

"19:25:30, 20 czerwca 2015: Image saved"!

!Instrument class methodsFor!
contract: contr on: obj
	^(Instrument new) ! !
!Instrument class categoriesFor: #contract:on:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument class methodsFor!
new
	^super new! !
!Instrument class categoriesFor: #new!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

p :=ProtoObject new.!

p :=ProtoObject new.!

p :=ProtoObject new.!

p :=ProtoObject new.!

!ContractViolation methodsFor!
isResumable
	^true! !
!ContractViolation categoriesFor: #isResumable!public! !

ContractViolation subclass: #InvariantViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
InvariantViolation guid: (GUID fromString: '{93771876-6E5D-41DA-BBB7-A055B559CD73}')!
InvariantViolation comment: ''!
!InvariantViolation categoriesForClass!Unclassified! !
ContractViolation subclass: #ConditionViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ConditionViolation guid: (GUID fromString: '{4A410916-2BB2-4B1C-8141-9C242661B547}')!
ConditionViolation comment: ''!
!ConditionViolation categoriesForClass!Unclassified! !
ConditionViolation subclass: #PreconditionViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
PreconditionViolation guid: (GUID fromString: '{4516B15B-74D3-4482-9AD0-2CC07A87CFD5}')!
PreconditionViolation comment: ''!
!PreconditionViolation categoriesForClass!Unclassified! !
ConditionViolation subclass: #PostconditionViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
PostconditionViolation guid: (GUID fromString: '{6347CAA0-DABE-4733-975A-9C95B1C581F8}')!
PostconditionViolation comment: ''!
!PostconditionViolation categoriesForClass!Unclassified! !
Error subclass: #ContractViolation
	instanceVariableNames: 'obj'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ContractViolation methodsFor!
object: aObj
	obj := aObj.
	! !
!ContractViolation categoriesFor: #object:!public! !

!ContractViolation methodsFor!
object
	^obj! !
!ContractViolation categoriesFor: #object!public! !

Error subclass: #ContractViolation
	instanceVariableNames: 'obj cond'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ContractViolation methodsFor!
condition: aCond
	cond := aCond.! !
!ContractViolation categoriesFor: #condition:!public! !

!ContractViolation methodsFor!
condition
	^cond! !
!ContractViolation categoriesFor: #condition!public! !

ContractViolation subclass: #ConditionViolation
	instanceVariableNames: 'meth'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ConditionViolation methodsFor!
method: aMeth
	meth := aMeth.! !
!ConditionViolation categoriesFor: #method:!public! !

!ConditionViolation methodsFor!
method
	^meth! !
!ConditionViolation categoriesFor: #method!public! !

"20:45:30, 20 czerwca 2015: Image saved"!

ProtoObject subclass: #Instrument
	instanceVariableNames: 'contr object'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Instrument class methodsFor!
contract: aContr on: aObj
	^super new contract: aContr object: aObj! !
!Instrument class categoriesFor: #contract:on:!public! !

ProtoObject subclass: #Instrument
	instanceVariableNames: 'contr obj'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Instrument class removeSelector: #new ifAbsent: []!

!Instrument methodsFor!
contract: aContr
	contr := aContr.! !
!Instrument categoriesFor: #contract:!public! !

!Instrument methodsFor!
object: aObj
	obj := aObj.! !
!Instrument categoriesFor: #object:!public! !

!Instrument methodsFor!
object: aObj
	obj := aObj.! !
!Instrument categoriesFor: #object:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = Object) not ifTrue: [
		res := res sum: (self class: cls).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = Object) ifFalse: [
		res := res sum: (self class: cls).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = Object) ifFalse: [
		res := res sum: (self class: cls).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: ao.!

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: (other methods).
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: (other methods).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: ao.!

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: ((other methods) collection).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: ao.!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: ao.!

"21:30:17, 20 czerwca 2015: Image saved"!

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants;
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [InvariantViolation new object: obj condition: inv; signal.]
	].
	msg forwardTo: obj
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(InvariantViolation new) object: obj condition: inv; signal.]
	].
	msg forwardTo: obj
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(InvariantViolation new) object: obj condition: inv; signal.]
	].
	msg forwardTo: obj.
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument class methodsFor!
contract: aContr on: aObj
	^(super new) contract: aContr object: aObj! !
!Instrument class categoriesFor: #contract:on:!public! !

Instrument removeSelector: #object: ifAbsent: []!

!Instrument methodsFor!
contract: aContr object: aObj
	contr := aContr.
	obj := aObj.! !
!Instrument categoriesFor: #contract:object:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	msg forwardTo: obj.
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

Instrument removeSelector: #contract: ifAbsent: []!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [^(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [^(((PreconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [^(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [^(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

cb!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

cbo := cb contractFor: bo.!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

|s b|!

s := Set new.!

b := [:q | q x isNull].!

s add: b.!

s remove: b.!

s remove: b.!

|s b|
s := Set new.
b := [:q | q x isNull].
s add: b.
s remove: b.!

|s b|
s := Set new.
b := [:q | q x isNull].
s add: b.
s remove: b.!

|s b|
s := Set new.
b := [:q | q x isNull].
s add: b.
s remove: b.!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: ((invariantSet copy) union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: ((invariantSet copy) union: ((other invariants) copy)).
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: ((invariantSet copy) union: ((other invariants) copy)).
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	iSum := invariantSet copy.
	iSum addAll: (other invariants).
	res invariants: iSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

"23:58:16, 20 czerwca 2015: Image saved"!

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

"00:31:12, 21 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

!ContractBuilder methodsFor!
getClass: cls
	^self! !
!ContractBuilder categoriesFor: #getClass:!private! !

!ContractBuilder methodsFor!
class: cls
	^self getClass: cls! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
getClass: cls
	^(cbcDict at: cls ifAbsent: [cbcDict at: cls put: ((CBClass new) c: cls)])! !
!ContractBuilder categoriesFor: #getClass:!private! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = Object) ifFalse: [
		res := res sum: (self getClass: cls).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
class: cls
	|b res c|
	c := cls.
	res := (CBClass new) c: c.
	b := [:jmp |  (c = Object) ifFalse: [
		res := res sum: (self getClass: c).
		c := c superclass.
		jmp value: jmp] ].
	b value: b.
	^res! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	^self class: (obj class)
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	^(self class: (obj class))
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
class: cls
	|b res c|
	c := cls.
	res := self getClass: c.
	b := [:jmp |  (c = Object) ifFalse: [
		res := res sum: (self getClass: c).
		c := c superclass.
		jmp value: jmp] ].
	b value: b.
	^res! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
class: cls
	|b res c|
	c := cls.
	res := self getClass: c.
	b := [:jmp |  (c = Object) ifFalse: [
		res := res sum: (self getClass: c).
		c := c superclass.
		jmp value: jmp] ].
	b value: b.
	^res! !
!ContractBuilder categoriesFor: #class:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!CBClass methodsFor!
sum: other
	|mSum selfKeys otherKeys commonKeys iSum|
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	self methods: mSum.
	iSum := invariantSet copy.
	iSum addAll: (other invariants).
	self invariants: iSum.! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|mSum selfKeys otherKeys commonKeys iSum|
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	self methods: mSum.
	iSum := invariantSet copy.
	iSum addAll: (other invariants).
	self invariants: iSum.! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	self methods: mSum.
	iSum := invariantSet copy.
	iSum addAll: (other invariants).
	self invariants: iSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	self methods: mSum.
	iSum := invariantSet copy.
	iSum addAll: (other invariants).
	res invariants: iSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	iSum := invariantSet copy.
	iSum addAll: (other invariants).
	res invariants: iSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	^((self class: (obj class)) copy)
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
class: cls
	|b res c|
	c := cls.
	res := self getClass: c.
	b := [:jmp |  (c = Object) ifFalse: [
		res := res sum: (self getClass: c).
		c := c superclass.
		jmp value: jmp] ].
	b value: b.
	^(((self getClass: cls) invariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #class:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	^((self class: (obj class)) deepCopy)
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	^((self class: (obj class)) copy)
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
class: cls
	|b res c|
	c := cls.
	res := self getClass: c.
	b := [:jmp |  (c = Object) ifFalse: [
		res := res sum: (self getClass: c).
		c := c superclass.
		jmp value: jmp] ].
	b value: b.
	^(((self getClass: cls) invariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #class:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!CBClass methodsFor!
copy
	|res|
	res := CBClass new.
	res invariants: (invariantSet copy).
	res methods: (methodDict copy).
	^res! !
!CBClass categoriesFor: #copy!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!ContractBuilder methodsFor!
class: cls
	|b res|
	res := self getClass: cls.
	b := [:jmp :locC |  (locC = Object) ifFalse: [
		jmp value: jmp value: (locC superclass).
		res := res sum: (self getClass: locC).] ].
	b value: b value: cls.
	^(((self getClass: cls) invariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
class: cls
	|b res|
	res := self getClass: cls.
	b := [:jmp :locC |  (locC = Object) ifFalse: [
		jmp value: jmp value: (locC superclass).
		res := res sum: (self getClass: locC).] ].
	b value: b value: cls.
	^(((self getClass: cls) invariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #class:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond value: obj valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond value: obj valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		((preCond value: obj) valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		((postCond value: obj) valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		((preCond value: obj) valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		((postCond value: obj) valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		((preCond value: obj) valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		((postCond value: obj) valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

"01:10:44, 21 czerwca 2015: Image saved"!

"10:17:06, 21 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #CBClass
	instanceVariableNames: 'c invToAdd invToRemove methodDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
initialize
	invToAdd := Set new.
	invToRemove := Set new.
	methodDict := Dictionary new.! !
!CBClass categoriesFor: #initialize!public! !

!CBClass methodsFor!
addInvariant: inv
	invToAdd add: inv.! !
!CBClass categoriesFor: #addInvariant:!public! !

!CBClass methodsFor!
removeInvariant: inv
	invToRemove add: inv.
	invToAdd includes: inv ifTrue: [invToAdd remove: inv].! !
!CBClass categoriesFor: #removeInvariant:!public! !

!CBClass methodsFor!
removeInvariant: inv
	invToRemove add: inv.
	(invToAdd includes: inv) ifTrue: [invToAdd remove: inv].! !
!CBClass categoriesFor: #removeInvariant:!public! !

!CBClass methodsFor!
addInvariant: inv
	invToAdd add: inv.
	(invToRemove includes: inv) ifTrue: [invToRemove remove: inv].! !
!CBClass categoriesFor: #addInvariant:!public! !

!CBClass methodsFor!
invariants
	^((invToAdd copy) difference: invToRemove)! !
!CBClass categoriesFor: #invariants!public! !

!CBClass methodsFor!
invariants: invs
	invToRemove := Set new.
	invToAdd := invs.! !
!CBClass categoriesFor: #invariants:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	iSum := self invariants.
	iSum addAll: (other invariants).
	res invariants: iSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	iSum := self invariants.
	iSum addAll: (other invariants).
	res invariants: iSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	iSum := self invariants.
	iSum addAll: (other invariants).
	res invariants: iSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!CBClass methodsFor!
copy
	|res|
	res := CBClass new.
	res invariants: ((self invariants) copy).
	res methods: (methodDict copy).
	^res! !
!CBClass categoriesFor: #copy!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res signature|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	signature := msg selectors.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: signature) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		((postCond value: obj) valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res signature|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		((postCond value: obj) valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		((postCond value: obj) valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

Object subclass: #CBClass
	instanceVariableNames: 'c invToAdd invToRemove parentInvSet methodDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
initialize
	invToAdd := Set new.
	invToRemove := Set new.
	methodDict := Dictionary new.
	parentInvSet := Set new.! !
!CBClass categoriesFor: #initialize!public! !

!CBClass methodsFor!
invariants: invs
	parentInvSet := invs.! !
!CBClass categoriesFor: #invariants:!public! !

!CBClass methodsFor!
invariants
	^(((parentInvSet copy) union: (invToAdd copy)) difference: invToRemove)! !
!CBClass categoriesFor: #invariants!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: self invariants.
	iSum addAll: (other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: self invariants.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: self invariants.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: self invariants.
	(other invariants) do: [:inv | res addInvariant: inv].
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: (args, #(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

CBClass removeSelector: #copy ifAbsent: []!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	^((CBClass new) invariants: (self class: (obj class)) invariants copy)
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|orig invs meths|
	orig := self class: (obj class).
	invs := orig invariants copy.
	meths := orig methods copy.
	^(((CBClass new) invariants: invs) methods: meths)
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |!

cb := ContractBuilder new.!

ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.!

ao := ac new.!

i1 := [:q | q x notNil].!

(cb class: ac) addInvariant: i1.!

ac compile: 'x ^x'.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

cao := cb contractFor: ao.!

iao := Instrument contract: cao on: ao.!

t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].!

t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
!

ac compile: 'x: a x := a. ^x'.!

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].!

cao removeInvariant: i1.!

ao x: nil.!

t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].!

t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].!

bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.!

bo := bc new.!

bc compile: 'y ^y'.!

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

i2 := [:q | q y isNil].!

i3 := [:q | 1 + 2 * 3 = 9].!

(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.!

cbo := cb contractFor: bo.!

t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].!

i4 := [:q :a | a = 5].!

i5 := [:q :a :w | a * a = w].!

((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.!

bc compile: 'f: a ^a * a * a'.!

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

ibo := Instrument contract: (cb contractFor: bo) on: bo.!

t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].!

t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

"12:46:12, 21 czerwca 2015: Image saved"!

"13:22:18, 21 czerwca 2015: Image saved"!

"14:12:06, 21 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

CBClass removeSelector: #c: ifAbsent: []!

!CBClass methodsFor!
initialize
	invToAdd := Set new.
	invToRemove := Set new.
	methodDict := Dictionary new.
	parentInvSet := Set new.! !
!CBClass categoriesFor: #initialize!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!ContractBuilder methodsFor!
getClass: cls
	^(cbcDict at: cls ifAbsent: [cbcDict at: cls put: (CBClass new)])! !
!ContractBuilder categoriesFor: #getClass:!private! !

CBMethod removeSelector: #method: ifAbsent: []!

Object subclass: #CBMethod
	instanceVariableNames: 'preSet postSet'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #CBClass
	instanceVariableNames: 'invToAdd invToRemove parentInvSet methodDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!CBClass methodsFor!
method: meth
	^(methodDict at: meth ifAbsent: [methodDict at: meth put: (CBMethod new)])! !
!CBClass categoriesFor: #method:!public! !

!CBClass methodsFor!
method: meth
	^(methodDict at: meth ifAbsent: [methodDict at: meth put: (CBMethod new)])! !
!CBClass categoriesFor: #method:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

(Package manager packageNamed: 'Contracts') comment: ''!

!CBClass methodsFor!
initialize
	invToAdd := IdentitySet new.
	invToRemove := IdentitySet new.
	methodDict := Dictionary new.
	parentInvSet := IdentitySet new.! !
!CBClass categoriesFor: #initialize!public! !

!CBMethod methodsFor!
initialize
	preSet := IdentitySet new.
	postSet := IdentitySet new! !
!CBMethod categoriesFor: #initialize!public! !

!CBMethod methodsFor!
initialize
	preSet := IdentitySet new.
	postSet := IdentitySet new.! !
!CBMethod categoriesFor: #initialize!public! !

!Instrument methodsFor!
contract: aContr object: aObj
	contr := aContr.
	obj := aObj.! !
!Instrument categoriesFor: #contract:object:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
contract: aContr object: aObj
	contr := aContr.
	obj := aObj.! !
!Instrument categoriesFor: #contract:object:!public! !

"14:39:01, 21 czerwca 2015: Image saved"!

Object subclass: #CBClass
	instanceVariableNames: 'invToAddSet invToRemoveSet parentInvSet methodDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
addInvariant: inv
	invToAddSet add: inv.
	(invToRemoveSet includes: inv) ifTrue: [invToRemoveSet remove: inv].! !
!CBClass categoriesFor: #addInvariant:!public! !

!CBClass methodsFor!
initialize
	invToAddSet := IdentitySet new.
	invToRemoveSet := IdentitySet new.
	methodDict := Dictionary new.
	parentInvSet := IdentitySet new.! !
!CBClass categoriesFor: #initialize!public! !

!CBClass methodsFor!
invariants
	^(((parentInvSet copy) union: (invToAddSet copy)) difference: invToRemoveSet)! !
!CBClass categoriesFor: #invariants!public! !

!CBClass methodsFor!
removeInvariant: inv
	invToRemoveSet add: inv.
	(invToAddSet includes: inv) ifTrue: [invToAddSet remove: inv].! !
!CBClass categoriesFor: #removeInvariant:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: self invariants.
	(other invariants) do: [:inv | res addInvariant: inv].
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: self invariants.
	(other invariants) do: [:inv | res addInvariant: inv].
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

"15:05:35, 21 czerwca 2015: Image saved"!

"15:10:17, 21 czerwca 2015: Image saved"!
"20:55:24, 21 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!CBClass methodsFor!
addInvariant: inv
	"Adds the invariant to the class representation."
	invToAddSet add: inv.
	(invToRemoveSet includes: inv) ifTrue: [invToRemoveSet remove: inv].! !
!CBClass categoriesFor: #addInvariant:!public! !

!CBClass methodsFor!
removeInvariant: inv
	"Adds the invariant from the class representation."
	invToRemoveSet add: inv.
	(invToAddSet includes: inv) ifTrue: [invToAddSet remove: inv].! !
!CBClass categoriesFor: #removeInvariant:!public! !

!CBClass methodsFor!
invariants
	"Returns all the invariants for the given class."
	^(((parentInvSet copy) union: (invToAddSet copy)) difference: invToRemoveSet)! !
!CBClass categoriesFor: #invariants!public! !

!CBClass methodsFor!
parentInvariants: invs
	parentInvSet := invs.! !
!CBClass categoriesFor: #parentInvariants:!public! !

CBClass removeSelector: #invariants: ifAbsent: []!

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res parentInvariants: self invariants.
	(other invariants) do: [:inv | res addInvariant: inv].
	^res! !
!CBClass categoriesFor: #sum:!public! !

!ContractBuilder methodsFor!
class: cls
	|b res|
	res := self getClass: cls.
	b := [:jmp :locC |  (locC = Object) ifFalse: [
		jmp value: jmp value: (locC superclass).
		res := res sum: (self getClass: locC).] ].
	b value: b value: cls.
	^(((self getClass: cls) parentInvariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|orig invs meths|
	orig := self class: (obj class).
	invs := orig invariants copy.
	meths := orig methods copy.
	^(((CBClass new) parentInvariants: invs) methods: meths)
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
initialize
	cbcDict := Dictionary new! !
!ContractBuilder categoriesFor: #initialize!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!ContractBuilder methodsFor!
getClass: cls
	"Extract or create a class representatio object."
	^(cbcDict at: cls ifAbsent: [cbcDict at: cls put: (CBClass new)])! !
!ContractBuilder categoriesFor: #getClass:!private! !

!Instrument methodsFor!
executeInvariants: invariants for: obj
	! !
!Instrument categoriesFor: #executeInvariants:for:!private! !

!Instrument methodsFor!
executeInvariants: invariants for: obj
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].! !
!Instrument categoriesFor: #executeInvariants:for:!private! !

!Instrument methodsFor!
executeInvariants: invariants
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].! !
!Instrument categoriesFor: #executeInvariants:!private! !

Instrument removeSelector: #executeInvariants:for: ifAbsent: []!

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: (args, #(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: (args, #(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
run: conditions on: method withArgs: args failWith: exp
	((contr method: method) conditions) do: [:cond |
		(cond valueWithArguments: args) ifFalse:  [((((exp new) object: obj) condition: cond) method: method) signal.]
	].! !
!Instrument categoriesFor: #run:on:withArgs:failWith:!private! !

Instrument removeSelector: #run:on:withArgs:failWith: ifAbsent: []!

!Instrument methodsFor!
check: condition for: method with: args
	(condition valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: condition) method: method) signal.].! !
!Instrument categoriesFor: #check:for:with:!private! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond | self check: preCond for: meth with: args.].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: (args, #(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond | self check: preCond for: meth with: args.].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do:  [:postCond | self check: postCond for: meth with: (args, #(res)).].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond | self check: preCond for: meth with: args.].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do:  [:postCond | self check: postCond for: meth with: (args, #(res)).].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond | self check: preCond for: meth with: args.].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond | self check: postCond for: meth with: (args, #(res)).].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (#(obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

Instrument removeSelector: #check:for:with: ifAbsent: []!

!Instrument methodsFor!
executeInvariants: invariants
	"Executes and checks if the invariants hold for the contract."
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].! !
!Instrument categoriesFor: #executeInvariants:!private! !

"22:54:38, 21 czerwca 2015: Image saved"!

!CBClass methodsFor!
methods
	"Returns the dictionary with all methods for the class."
	^methodDict! !
!CBClass categoriesFor: #methods!public! !

!CBClass methodsFor!
methods: meths
	"Setter for methods."
	methodDict := meths.! !
!CBClass categoriesFor: #methods:!public! !

!CBClass methodsFor!
parentInvariants: invs
	"Setter for parent invariants. Sets the parent invariants of this class to the given value (Set)."
	parentInvSet := invs.! !
!CBClass categoriesFor: #parentInvariants:!public! !

!CBClass methodsFor!
removeInvariant: inv
	"Removes the invariant from the class representation."
	invToRemoveSet add: inv.
	(invToAddSet includes: inv) ifTrue: [invToAddSet remove: inv].! !
!CBClass categoriesFor: #removeInvariant:!public! !

!CBClass methodsFor!
sum: other
	"Returns a new object representing a sum of invariants and method conditions for 2 class objects."
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res parentInvariants: self invariants.
	(other invariants) do: [:inv | res addInvariant: inv].
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	"Returns a new object representing a sum of invariants and method conditions for 2 class objects."
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res parentInvariants: self invariants.
	(other invariants) do: [:inv | res addInvariant: inv].
	^res! !
!CBClass categoriesFor: #sum:!public! !

"23:01:50, 21 czerwca 2015: Image saved"!

"12:13:42, 22 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

"12:13:57, 22 czerwca 2015: Image saved"!

!ContractBuilder methodsFor!
getClass: cls
	"Extract or create a class representation object."
	^(cbcDict at: cls ifAbsent: [cbcDict at: cls put: (CBClass new)])! !
!ContractBuilder categoriesFor: #getClass:!private! !

"12:18:57, 22 czerwca 2015: Image saved"!

"16:02:00, 22 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #CBMethod
	instanceVariableNames: 'preAddSet preParentSet preRemoveSet postAddSet postParentSet postRemoveSet'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBMethod methodsFor!
postConditions
	^(((postParentSet  copy) union: postAddSet) difference: postRemoveSet)! !
!CBMethod categoriesFor: #postConditions!public! !

!CBMethod methodsFor!
preConditions
	^(((preParentSet  copy) union: preAddSet) difference: preRemoveSet)! !
!CBMethod categoriesFor: #preConditions!public! !

!CBMethod methodsFor!
postConditions: conditions
	postParentSet := conditions! !
!CBMethod categoriesFor: #postConditions:!public! !

!CBMethod methodsFor!
preConditions: conditions
	preParentSet := conditions! !
!CBMethod categoriesFor: #preConditions:!public! !

!CBMethod methodsFor!
removePostcondition: cond! !
!CBMethod categoriesFor: #removePostcondition:!public! !

!CBMethod methodsFor!
removePrecondition: cond
	preRemoveSet add: cond.
	(preAddSet includes: cond) ifTrue: [preAddSet remove: cond].! !
!CBMethod categoriesFor: #removePrecondition:!public! !

!CBMethod methodsFor!
removePostcondition: cond
	postRemoveSet add: cond.
	(postAddSet includes: cond) ifTrue: [postAddSet remove: cond].! !
!CBMethod categoriesFor: #removePostcondition:!public! !

!CBMethod methodsFor!
initialize
	preParentSet := IdentitySet new.
	preAddSet := IdentitySet new.
	preRemoveSet := IdentitySet new.
	postParentSet := IdentitySet new.
	postAddSet := IdentitySet new.
	postRemoveSet := IdentitySet new.! !
!CBMethod categoriesFor: #initialize!public! !

!CBMethod methodsFor!
addPrecondition: cond
	preAddSet add: cond.
	(preRemoveSet includes: cond) ifTrue: [preRemoveSet remove: cond].! !
!CBMethod categoriesFor: #addPrecondition:!public! !

!CBMethod methodsFor!
addPostcondition: cond
	postAddSet add: cond.
	(postRemoveSet includes: cond) ifTrue: [postRemoveSet remove: cond].! !
!CBMethod categoriesFor: #addPostcondition:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!CBClass methodsFor!
removeInvariant: inv
	"Removes the invariant from the class representation."
	invToRemoveSet add: inv.
	(invToAddSet includes: inv) ifTrue: [invToAddSet remove: inv].! !
!CBClass categoriesFor: #removeInvariant:!public! !

"17:27:50, 22 czerwca 2015: Image saved"!

!CBClass methodsFor!
present: invariant
	|invs|
	invs := self invariants.
	^invs includes: invariant.! !
!CBClass categoriesFor: #present:!private! !

Error subclass: #MalformedContract
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
MalformedContract guid: (GUID fromString: '{17F290E8-9E6C-44E3-A670-3BEEA8190395}')!
MalformedContract comment: ''!
!MalformedContract categoriesForClass!Unclassified! !
Error subclass: #MalformedContract
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
addInvariant: inv
	"Adds the invariant to the class representation."
	(self present: inv) ifTrue: [MalformedContract signal: 'Trying to add an invariant that already applies to the class!!'.].
	invToAddSet add: inv.
	(invToRemoveSet includes: inv) ifTrue: [invToRemoveSet remove: inv].! !
!CBClass categoriesFor: #addInvariant:!public! !

!CBClass methodsFor!
removeInvariant: inv
	"Removes the invariant from the class representation."
	(self present: inv) ifFalse: [MalformedContract signal: 'Trying to remove an invariant that does not apply to the class!!'.].
	invToRemoveSet add: inv.
	(invToAddSet includes: inv) ifTrue: [invToAddSet remove: inv].! !
!CBClass categoriesFor: #removeInvariant:!public! !

!CBClass methodsFor!
addTo: addSet removeFrom: removeSet! !
!CBClass categoriesFor: #addTo:removeFrom:!private! !

!CBClass methodsFor!
add: invariant to: addSet removeFrom: removeSet! !
!CBClass categoriesFor: #add:to:removeFrom:!private! !

!CBClass methodsFor!
add: invariant to: addSet removeFrom: removeSet
	addSet add: invariant.
	(removeSet includes: invariant) ifTrue: [removeSet remove: invariant].! !
!CBClass categoriesFor: #add:to:removeFrom:!private! !

CBClass removeSelector: #addTo:removeFrom: ifAbsent: []!

!CBClass methodsFor!
add: invariant to: addSet removeFrom: removeSet
	addSet add: invariant.
	(removeSet includes: invariant) ifTrue: [removeSet remove: invariant].! !
!CBClass categoriesFor: #add:to:removeFrom:!private! !

!CBClass methodsFor!
addInvariant: inv
	"Adds the invariant to the class representation."
	(self present: inv) ifTrue: [MalformedContract signal: 'Trying to add an invariant that already applies to the class!!'.].
	self add: inv to: invToAddSet removeFrom: invToRemoveSet.! !
!CBClass categoriesFor: #addInvariant:!public! !

!CBClass methodsFor!
removeInvariant: inv
	"Removes the invariant from the class representation."
	(self present: inv) ifFalse: [MalformedContract signal: 'Trying to remove an invariant that does not apply to the class!!'.].
	self add: inv to: invToRemoveSet removeFrom: invToAddSet.! !
!CBClass categoriesFor: #removeInvariant:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!CBClass methodsFor!
sum: other
	"Returns a new object representing a sum of invariants and method conditions for 2 class objects."
	|res mSum selfKeys otherKeys commonKeys invs|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	invs := (self invariants) copy.
	(other invariants) do: [:inv | res addInvariant: inv].
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	"Returns a new object representing a sum of invariants and method conditions for 2 class objects."
	|res mSum selfKeys otherKeys commonKeys invs|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	invs := (self invariants) copy.
	(other invariants) do: [:inv | invs add: inv].
	res parentInvariants: invs.
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
sum: other
	"Returns a new object representing a sum of invariants and method conditions for 2 class objects."
	|res mSum selfKeys otherKeys commonKeys invs|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	invs := ((self invariants) copy).
	(other invariants) do: [:inv | invs add: inv].
	res parentInvariants: invs.
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
addInvariant: inv
	"Adds the invariant to the class representation."
	"(self present: inv) ifTrue: [MalformedContract signal: 'Trying to add an invariant that already applies to the class!!'.]."
	self add: inv to: invToAddSet removeFrom: invToRemoveSet.! !
!CBClass categoriesFor: #addInvariant:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!CBClass methodsFor!
addInvariant: inv
	"Adds the invariant to the class representation."
	(self present: inv) ifTrue: [MalformedContract signal: 'Trying to add an invariant that already applies to the class!!'.].
	self add: inv to: invToAddSet removeFrom: invToRemoveSet.! !
!CBClass categoriesFor: #addInvariant:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
addInvariant: inv
	"Adds the invariant to the class representation."
	(self present: inv) ifTrue: [MalformedContract signal: 'Trying to add an invariant that already applies to the class!!'.].
	self add: inv to: invToAddSet removeFrom: invToRemoveSet.! !
!CBClass categoriesFor: #addInvariant:!public! !

!CBMethod methodsFor!
add: condition to: addSet removeFrom: removeSet! !
!CBMethod categoriesFor: #add:to:removeFrom:!private! !

!CBMethod methodsFor!
add: condition to: addSet removeFrom: removeSet
	addSet add: condition.
	(removeSet includes: condition) ifTrue: [removeSet remove: condition].! !
!CBMethod categoriesFor: #add:to:removeFrom:!private! !

!CBMethod methodsFor!
addPostcondition: cond
	self add: cond to: postAddSet removeFrom: postRemoveSet.! !
!CBMethod categoriesFor: #addPostcondition:!public! !

!CBMethod methodsFor!
addPrecondition: cond
	self add: cond to: preAddSet removeFrom: preRemoveSet.! !
!CBMethod categoriesFor: #addPrecondition:!public! !

!CBMethod methodsFor!
removePostcondition: cond
	self add: cond to: postRemoveSet removeFrom: postAddSet.! !
!CBMethod categoriesFor: #removePostcondition:!public! !

!CBMethod methodsFor!
removePostcondition: cond
	self add: cond to: postRemoveSet removeFrom: postAddSet.! !
!CBMethod categoriesFor: #removePostcondition:!public! !

!CBMethod methodsFor!
removePrecondition: cond
	self add: cond to: preRemoveSet removeFrom: preAddSet.! !
!CBMethod categoriesFor: #removePrecondition:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!CBMethod methodsFor!
addPostcondition: cond
	(self postConditions includes: cond) ifTrue: [MalformedContract signal: 'Trying to add a postcondition that already applies to the method!!'].
	self add: cond to: postAddSet removeFrom: postRemoveSet.! !
!CBMethod categoriesFor: #addPostcondition:!public! !

!CBMethod methodsFor!
addPrecondition: cond
	(self preConditions includes: cond) ifTrue: [MalformedContract signal: 'Trying to add a precondition that already applies to the method!!'].
	self add: cond to: preAddSet removeFrom: preRemoveSet.! !
!CBMethod categoriesFor: #addPrecondition:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBMethod methodsFor!
addPrecondition: cond
	(self preConditions includes: cond) ifTrue: [MalformedContract signal: 'Trying to add a precondition that already applies to the method!!'].
	self add: cond to: preAddSet removeFrom: preRemoveSet.! !
!CBMethod categoriesFor: #addPrecondition:!public! !

!CBMethod methodsFor!
removePrecondition: cond
	(self preConditions includes: cond) ifFalse: [MalformedContract signal: 'Trying to remove a precondition that does not apply to the method!!'].
	self add: cond to: preRemoveSet removeFrom: preAddSet.! !
!CBMethod categoriesFor: #removePrecondition:!public! !

"18:15:31, 22 czerwca 2015: Image saved"!

"20:03:11, 22 czerwca 2015: Image saved"!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

Object subclass: #ClassHelper
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ClassHelper guid: (GUID fromString: '{42E9B73F-8E3C-430F-9CE2-4D3C80BA8A45}')!
ClassHelper comment: ''!
!ClassHelper categoriesForClass!Unclassified! !
Object subclass: #ClassHelper
	instanceVariableNames: 'cbcDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ClassHelper class methodsFor!
new
	^super new initialize! !
!ClassHelper class categoriesFor: #new!public! !

ClassHelper class removeSelector: #new ifAbsent: []!

!ClassHelper methodsFor!
setCBCDict: dict
	cbcDict := dict.! !
!ClassHelper categoriesFor: #setCBCDict:!public! !

Object subclass: #ClassHelper
	instanceVariableNames: 'cbcDict cls'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ClassHelper methodsFor!
class: aCls
	cls := aCls.! !
!ClassHelper categoriesFor: #class:!public! !

!ClassHelper methodsFor!
addInvariant: inv! !
!ClassHelper categoriesFor: #addInvariant:!public! !

!ContractBuilder methodsFor!
getClassObject: cls
	! !
!ContractBuilder categoriesFor: #getClassObject:!public! !

!ContractBuilder methodsFor!
getClassObject: cls
	|b res|
	res := self getClass: cls.
	b := [:jmp :locC |  (locC = Object) ifFalse: [
		jmp value: jmp value: (locC superclass).
		res := res sum: (self getClass: locC).] ].
	b value: b value: cls.
	^(((self getClass: cls) parentInvariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #getClassObject:!public! !

Object subclass: #ClassHelper
	instanceVariableNames: 'cb cls'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ClassHelper methodsFor!
setCB: aCB
	cb := aCB.! !
!ClassHelper categoriesFor: #setCB:!public! !

ClassHelper removeSelector: #setCBCDict: ifAbsent: []!

!ClassHelper methodsFor!
addInvariant: inv
	(cb getClassObject: cls) addInvariant: inv.! !
!ClassHelper categoriesFor: #addInvariant:!public! !

ClassHelper removeFromSystem!

ContractBuilder removeSelector: #getClassObject: ifAbsent: []!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
addInvariant: inv
	"Adds the invariant to the class representation."
	self add: inv to: invToAddSet removeFrom: invToRemoveSet.! !
!CBClass categoriesFor: #addInvariant:!public! !

!CBMethod methodsFor!
addPrecondition: cond
	self add: cond to: preAddSet removeFrom: preRemoveSet.! !
!CBMethod categoriesFor: #addPrecondition:!public! !

!CBMethod methodsFor!
addPostcondition: cond
	self add: cond to: postAddSet removeFrom: postRemoveSet.! !
!CBMethod categoriesFor: #addPostcondition:!public! !

!CBMethod methodsFor!
removePostcondition: cond
	(self postConditions includes: cond) ifFalse: [MalformedContract signal: 'Trying to remove a postcondition that does not apply to the method!!'].
	self add: cond to: postRemoveSet removeFrom: postAddSet.! !
!CBMethod categoriesFor: #removePostcondition:!public! !

!CBMethod methodsFor!
removePostcondition: cond
	(self postConditions includes: cond) ifFalse: [MalformedContract signal: 'Trying to remove a postcondition that does not apply to the method!!'].
	self add: cond to: postRemoveSet removeFrom: postAddSet.! !
!CBMethod categoriesFor: #removePostcondition:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

"21:02:24, 22 czerwca 2015: Image saved"!

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := ((Array new) put: obj, msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (((Array new) put: obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (((Array new) at: 1 put: obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := ((Array with: (obj@1)), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := ((Array new: 1) at: 1 put: obj, msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	args := (((Array new: 1) at: 1 put: obj), msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res objArr resArr|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	objArr := Array new: 1.
	objArr at: 1 put: obj.
	args := (objArr, msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res objArr resArr|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	objArr := Array new: 1.
	resArr := Array new: 1.
	objArr at: 1 put: obj.
	args := (objArr, msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res objArr resArr|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	objArr := Array new: 1.
	resArr := Array new: 1.
	objArr at: 1 put: obj.
	args := (objArr, msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	resArr at: 1 put: res.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,#(res))) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res objArr resArr|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	objArr := Array new: 1.
	resArr := Array new: 1.
	objArr at: 1 put: obj.
	args := (objArr, msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	resArr at: 1 put: res.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,resArr)) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res objArr resArr|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	objArr := Array new: 1.
	resArr := Array new: 1.
	objArr at: 1 put: obj.
	args := (objArr, msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	resArr at: 1 put: res.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,resArr)) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

"21:12:02, 22 czerwca 2015: Image saved"!

CBClass comment:
'A simple object that represents a contract for a class. It allows for changing the invariants and has a getter for methodswhich serve the same purpose.'!
CBMethod comment:
'A CBClass counterpart for methods.'!
!ContractBuilder methodsFor!
contractFor: obj
	"Creates a copy of an object that would be created for the #class call for the given class."
	|orig invs meths|
	orig := self class: (obj class).
	invs := orig invariants copy.
	meths := orig methods copy.
	^(((CBClass new) parentInvariants: invs) methods: meths)
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	"Creates a semi-deep copy of an object that would be created for the #class call for the given class."
	|orig invs meths|
	orig := self class: (obj class).
	invs := orig invariants copy.
	meths := orig methods copy.
	^(((CBClass new) parentInvariants: invs) methods: meths)
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
class: cls
	"Creates an object that is aware of the invariants and method conditions of all it's superclasses at the time of creation and can store info about their changes."
	|b res|
	res := self getClass: cls.
	b := [:jmp :locC |  (locC = Object) ifFalse: [
		jmp value: jmp value: (locC superclass).
		res := res sum: (self getClass: locC).] ].
	b value: b value: cls.
	^(((self getClass: cls) parentInvariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #class:!public! !

CBClass comment:
'A simple object that represents a contract for a class. It allows for changing the invariants and has a getter for methods which serve the same purpose.'!
CBClass comment:
'A simple object that represents a contract for a class. It allows for changing the invariants and has a getter for methods which can change conditions.'!
Instrument comment:
'A class that represents an object ''augmented'' with invariants and pre/post conditions control.'!
!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res objArr resArr|
	invariants := contr invariants.
	self executeInvariants: invariants.
	meth := msg selector.
	"One-elem arrays created dynamically (no #())."
	objArr := Array new: 1.
	resArr := Array new: 1.
	objArr at: 1 put: obj.
	args := (objArr, msg arguments).
	((contr method: meth) preConditions) do: [:preCond |	
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.].
	].
	res := msg forwardTo: obj.
	resArr at: 1 put: res.
	self executeInvariants: invariants.
	((contr method: meth) postConditions) do: [:postCond |	
		(postCond valueWithArguments: (args,resArr)) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.].
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!ContractBuilder methodsFor!
class: cls
	"Creates an object that is aware of the invariants and method conditions of all it's superclasses at the time of creation and can store info about their changes."
	|b res|
	res := self getClass: cls.
	"A recursive block."
	b := [:jmp :locC |  (locC = Object) ifFalse: [
		jmp value: jmp value: (locC superclass).
		res := res sum: (self getClass: locC).] ].
	b value: b value: cls.
	^(((self getClass: cls) parentInvariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
class: cls
	"Creates an object that is aware of the invariants and method conditions of all it's superclasses at the time of creation and can store info about their changes."
	|b res|
	res := self getClass: cls.
	"A recursive block."
	b := [:jmp :locC |  
		(locC = Object) ifFalse: [
			jmp value: jmp value: (locC superclass).
			res := res sum: (self getClass: locC).] 
	].
	b value: b value: cls.
	^(((self getClass: cls) parentInvariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
class: cls
	"Creates an object that is aware of the invariants and method conditions of all it's superclasses at the time of creation and can store info about their changes."
	|b res|
	res := self getClass: cls.
	"A recursive block."
	b := [:jmp :locC |  
		(locC = Object) ifFalse: [
			jmp value: jmp value: (locC superclass).
			res := res sum: (self getClass: locC).] 
	].
	b value: b value: cls.
	^(((self getClass: cls) parentInvariants: (res invariants)) methods: (res methods))! !
!ContractBuilder categoriesFor: #class:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!B methodsFor!
f: a ^a * a * a! !
!B categoriesFor: #f:!public! !

"21:20:57, 22 czerwca 2015: Image saved"!

