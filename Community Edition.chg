"13:43:39, 14 czerwca 2015: Compressed sources"!

"13:43:42, 14 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

InstallationSessionManager removeFromSystem!

"13:43:43, 14 czerwca 2015: Image saved"!

Object subclass: #ContractBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ContractBuilder guid: (GUID fromString: '{0198A206-47FA-4D11-9E67-939A143528C7}')!
ContractBuilder comment: ''!
!ContractBuilder categoriesForClass!Unclassified! !
ProtoObject subclass: #Instrument
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
Instrument guid: (GUID fromString: '{EE67588F-9932-4A26-84ED-DCFBFB23B286}')!
Instrument comment: ''!
!Instrument categoriesForClass!Unclassified! !
Error subclass: #ContractViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ContractViolation guid: (GUID fromString: '{B8E71392-E924-4A22-B9ED-9FBC0ACC1782}')!
ContractViolation comment: ''!
!ContractViolation categoriesForClass!Unclassified! !
Error subclass: #ContractViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"14:38:40, 14 czerwca 2015: Image saved"!

"14:40:25, 14 czerwca 2015: Image saved"!

"19:21:27, 16 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #CBClass
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
CBClass guid: (GUID fromString: '{AA5CF289-B320-4A84-93E6-5B66093399B4}')!
CBClass comment: ''!
!CBClass categoriesForClass!Unclassified! !
Object subclass: #CBClass
	instanceVariableNames: 'c'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #CBClass
	instanceVariableNames: 'c'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ContractBuilder methodsFor!
class: cls
	|cbc|
	cbc := CBClass new;
	cbc c: cls;
	cbc.! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
class: cls
	|cbc|
	cbc := CBClass new.
	cbc c: cls.
	^ cbc.! !
!ContractBuilder categoriesFor: #class:!public! !

!

!

!

cbc := CBClass new.!

cbc.!

Object subclass: #CBClass
	instanceVariableNames: 'c'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
c: cls
	c := cls! !
!CBClass categoriesFor: #c:!public! !

!CBClass methodsFor!
c: cls
	c := cls! !
!CBClass categoriesFor: #c:!public! !

!ClassBuilder methodsFor!
class: cls
	|cbc|
	cbc := CBClass new.
	cbc c: cls.
	^cbc.! !
!ClassBuilder categoriesFor: #class:!public! !

!

cb := ClassBuilder new!

cb class: ClassBuilder!

"21:16:08, 16 czerwca 2015: Image saved"!

"18:05:28, 17 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

"20:06:12, 17 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!
Object subclass: #ClassBuilder
	instanceVariableNames: 'currentClass className instanceVariables superclass instanceSpec classVariables sharedPools comment flags categories cbcDict'
	classVariableNames: 'FixedInitialLayout FixedLayout IgnoreInstsMask RecompileMask Unsubclassable'
	poolDictionaries: '_BehaviorMasks'
	classInstanceVariableNames: ''!

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^ (self new)
	cbcDict: (Dictionary new);
	yourself.! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(self superclass) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(self new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(self new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(self new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder methodsFor!
initialize
	"Private - Initialize the instance."

	instanceSpec := 0.
	self beFixed.
	flags := 0.
	cbcDict := Dictionary new! !
!ClassBuilder categoriesFor: #initialize!initializing!private! !

d := Dictionary new;!

d at: 1!

d at: 1 ifAbsent: [d at: 1 put: 'a']!

d at: 1 ifAbsent: [d at: 1 put: 1]a DevelopmentSessionManager!

d at: 1 ifAbsent: [d at: 1 put: 1]!

d at: 1 ifAbsent: []!

d at: 1 ifAbsent: [];!

d at: 1 ifAbsent: [^d];Dictionary!

d at: 1 ifAbsent: [d];Dictionary!

d at: 1 ifAbsent: [d.]!

d at: 1 ifAbsent: [d;]!

d at: 1 ifAbsent: [:dict | dict at: 1 put: 1]!

d at: 1 ifAbsent: [:dict | dict at: 1 put: 1, dict]a DevelopmentSessionManager!

d at: 1 ifAbsent: ([:dict | dict at: 1 put: 1, dict])a DevelopmentSessionManager!

d at: 1 ifAbsent: [:dict | dict]a DevelopmentSessionManager!

d at: 1 ifAbsent: [:dict | dict]!

d at: 1!

d at: 1 put: 1!

d at: 1 put: 1.!

|d|!

d := Dictionary new;!

d at: 1 put: 1!

a := Dictionary new!

a at: 1 put: 1!

a!

a!

d at: 1 put: 1!

d := Dictionary new;Dictionary
d at: 1 put: 1!

d := Dictionary new;!

d at: 1 put: 1!

d := Dictionary new!

d at: 1 put: 1!

d at: 1 ifAbsent: [d at: 1 put: 1]!

d at: 1!

d := Dictionary new!

d at: 1 ifAbsent: [d at: 1 put: 1]!

d at: 2!

d at: 2 ifAbsent: [d at: 2 put: 2]!

!ClassBuilder methodsFor!
class: cls
	cbcDict at: cls ifAbsent: [cbcDict at: cls put: (CBClass new)]! !
!ClassBuilder categoriesFor: #class:!public! !

!ClassBuilder methodsFor!
class: cls
	cbcDict at: cls ifAbsent: [cbcDict at: cls put: ((CBClass new) c: cls)]! !
!ClassBuilder categoriesFor: #class:!public! !

cb := ClassBuilder new!

cb := ClassBuilder new!

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(superclass new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^(superclass new) initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

cb := ClassBuilder new!

cb class: ClassBuilder!

!ClassBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^super new initialize! !
!ClassBuilder class categoriesFor: #new!instance creation!public! !

cb := ClassBuilder new!

cb class: ClassBuilder!

"20:54:38, 17 czerwca 2015: Image saved"!

"09:25:53, 18 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!
Object subclass: #ClassBuilder
	instanceVariableNames: 'currentClass className instanceVariables superclass instanceSpec classVariables sharedPools comment flags categories'
	classVariableNames: 'FixedInitialLayout FixedLayout IgnoreInstsMask RecompileMask Unsubclassable'
	poolDictionaries: '_BehaviorMasks'
	classInstanceVariableNames: ''!

Object subclass: #ContractBuilder
	instanceVariableNames: 'cbcDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #ContractBuilder
	instanceVariableNames: 'cbcDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #ContractBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #ContractBuilder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"21:14:40, 18 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #ContractBuilder
	instanceVariableNames: 'cbcDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ContractBuilder methodsFor!
class: cls
	cbcDict at: cls ifAbsent: [cbcDict at: cls put: ((CBClass new) c: cls)]! !
!ContractBuilder categoriesFor: #class:!public! !

!ContractBuilder methodsFor!
initialize
	cbcDict := Dictionary new! !
!ContractBuilder categoriesFor: #initialize!public! !

!ContractBuilder class methodsFor!
new
	"Answer a new initialized instance."
	^super new initialize! !
!ContractBuilder class categoriesFor: #new!public! !

cb := ContractBuilder new!

cb class: Context!

!ContractBuilder methodsFor!
class: cls
	^(cbcDict at: cls ifAbsent: [cbcDict at: cls put: ((CBClass new) c: cls)])! !
!ContractBuilder categoriesFor: #class:!public! !

cb class: Context!

!ClassBuilder methodsFor!
class: aClass
	"Private - Set the currentClass inst var to the class to be modified, aClass."

	currentClass := aClass.
	self instanceSpec: aClass instanceSpec.! !
!ClassBuilder categoriesFor: #class:!public! !

!ClassBuilder methodsFor!
initialize
	"Private - Initialize the instance."

	instanceSpec := 0.
	self beFixed.
	flags := 0.! !
!ClassBuilder categoriesFor: #initialize!initializing!private! !

Object subclass: #ClassBuilder
	instanceVariableNames: 'currentClass className instanceVariables superclass instanceSpec classVariables sharedPools comment flags categories'
	classVariableNames: 'FixedInitialLayout FixedLayout IgnoreInstsMask RecompileMask Unsubclassable'
	poolDictionaries: '_BehaviorMasks'
	classInstanceVariableNames: ''!

cb := ClassBuilder new!

cb := ContractBuilder new!

"21:22:04, 18 czerwca 2015: Image saved"!

"22:04:02, 19 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #CBClass
	instanceVariableNames: 'c invariantSet methodSet'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass class methodsFor!
new
	"Answer a new initialized instance."
	^super new initialize! !
!CBClass class categoriesFor: #new!public! !

!CBClass methodsFor!
initialize
	invariantSet := Set new.
	methodSet := Set new.! !
!CBClass categoriesFor: #initialize!public! !

cb := ContractBuilder new!

cb class: ContractBuilder!

!CBClass methodsFor!
addInvariant: inv
	invariantSet add: inv! !
!CBClass categoriesFor: #addInvariant:!public! !

cb := ContractBuilder new!

o := cb class: ContractBuilder!

o addInvariant: [:cls | ^true]!

!CBClass methodsFor!
removeInvariant: inv
	invariantSet remove: inv! !
!CBClass categoriesFor: #removeInvariant:!public! !

CBClass subclass: #CBMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
CBMethod guid: (GUID fromString: '{A0B100F8-85ED-443D-B563-1BD230FD1FA7}')!
CBMethod comment: ''!
!CBMethod categoriesForClass!Unclassified! !
CBClass subclass: #Object
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Object subclass: #CBMethod
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
method: meth
	^(CBMethod new)! !
!CBClass categoriesFor: #method:!public! !

Object subclass: #CBClass
	instanceVariableNames: 'c invariantSet methodDict'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBClass methodsFor!
initialize
	invariantSet := Set new.
	methodDict := Dictionary new.! !
!CBClass categoriesFor: #initialize!public! !

!CBClass methodsFor!
method: meth
	^(methodDict at: meth ifAbsent: [methodDict at: meth put: (CBMethod new)])! !
!CBClass categoriesFor: #method:!public! !

"22:20:00, 19 czerwca 2015: Image saved"!

"15:33:24, 20 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

"15:33:51, 20 czerwca 2015: Dolphin Smalltalk X6 Community Edition started"!

Object subclass: #CBMethod
	instanceVariableNames: 'preSet postSet'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBMethod class methodsFor!
new
	^self initialize! !
!CBMethod class categoriesFor: #new!public! !

!CBMethod methodsFor!
initialize
	preSet = Set new.
	postSet = Set new.! !
!CBMethod categoriesFor: #initialize!public! !

!CBMethod class methodsFor!
new
	^super initialize! !
!CBMethod class categoriesFor: #new!public! !

!CBMethod class methodsFor!
new
	^super new initialize! !
!CBMethod class categoriesFor: #new!public! !

cb := ContractBuilder new!

o := cb class: ContractBuilder!

o method: #class!

!CBMethod methodsFor!
addPrecondition: cond
	preSet add: cond! !
!CBMethod categoriesFor: #addPrecondition:!public! !

!CBMethod methodsFor!
removePrecondition: cond
	preSet remove: cond! !
!CBMethod categoriesFor: #removePrecondition:!public! !

!CBMethod methodsFor!
addPostcondition: cond
	postSet add: cond! !
!CBMethod categoriesFor: #addPostcondition:!public! !

!CBMethod methodsFor!
removePostcondition: cond
	postSet remove: cond! !
!CBMethod categoriesFor: #removePostcondition:!public! !

m := o method: #class!

m addPrecondition: 1!

!CBMethod methodsFor!
initialize
	preSet = Set new,
	postSet = Set new! !
!CBMethod categoriesFor: #initialize!public! !

!CBMethod methodsFor!
initialize
	preSet = Set new,
	postSet = Set new! !
!CBMethod categoriesFor: #initialize!public! !

m := o method: #class!

m addPrecondition: 1!

m addPrecondition: 1.!

cb := ContractBuilder new.
o := cb class: ContractBuilder.
m := o method: #class.
m addPrecondition: 1.!

cb := ContractBuilder new.
o := cb class: ContractBuilder.
m := o method: #class.
m addPrecondition: 1.!

Object subclass: #CBMethod
	instanceVariableNames: 'meth preSet postSet'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!CBMethod methodsFor!
method: aMeth
	! !
!CBMethod categoriesFor: #method:!public! !

!CBMethod methodsFor!
method: aMeth
	meth := aMeth! !
!CBMethod categoriesFor: #method:!public! !

!CBMethod methodsFor!
method: aMeth
	meth := aMeth! !
!CBMethod categoriesFor: #method:!public! !

!CBClass methodsFor!
method: meth
	^(methodDict at: meth ifAbsent: [methodDict at: meth put: ((CBMethod new) method: meth)])! !
!CBClass categoriesFor: #method:!public! !

!CBClass methodsFor!
method: meth
	^(methodDict at: meth ifAbsent: [methodDict at: meth put: ((CBMethod new) method: meth)])! !
!CBClass categoriesFor: #method:!public! !

!CBMethod methodsFor!
initialize
	preSet := Set new.
	postSet := Set new! !
!CBMethod categoriesFor: #initialize!public! !

m := o method: #class.!

m addPrecondition: 1.!

!CBMethod methodsFor!
method
	^meth! !
!CBMethod categoriesFor: #method!public! !

CBMethod removeSelector: #method ifAbsent: []!

!CBMethod methodsFor!
method: aMeth
	meth := aMeth! !
!CBMethod categoriesFor: #method:!public! !

"16:01:08, 20 czerwca 2015: Image saved"!

"16:01:11, 20 czerwca 2015: Image saved"!

"16:01:18, 20 czerwca 2015: Image saved"!

!ContractBuilder methodsFor!
contractFor: obj
	|cls|
	cls := obj class.
	
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new! !
!CBMethod categoriesFor: #sum:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.

	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBMethod methodsFor!
preConditions
	^preSet! !
!CBMethod categoriesFor: #preConditions!public! !

!CBMethod methodsFor!
postConditions
	^postSet! !
!CBMethod categoriesFor: #postConditions!public! !

!CBMethod methodsFor!
preConditions: conditions
	preSet := conditions! !
!CBMethod categoriesFor: #preConditions:!public! !

!CBMethod methodsFor!
postConditions: conditions
	postSet := conditions! !
!CBMethod categoriesFor: #postConditions:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.
	res preConditions: (self preConditions + other preConditions).
	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.
	res preConditions: (self preConditions + other preConditions).
	res postConditions: (self postConditions + other postConditions).
	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.
	res preConditions: (self preConditions + other preConditions).
	res postConditions: (self postConditions + other postConditions).
	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBClass methodsFor!
methods: meths
	methodDict := meths.! !
!CBClass categoriesFor: #methods:!public! !

!CBClass methodsFor!
methods: meths
	methodDict := meths! !
!CBClass categoriesFor: #methods:!public! !

!CBClass methodsFor!
methods: meths
	methodDict := meths.! !
!CBClass categoriesFor: #methods:!public! !

!CBClass methodsFor!
methods
	^methodDict! !
!CBClass categoriesFor: #methods!public! !

!CBClass methodsFor!
sum: other
	|res|
	res := CBClass new.
	
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum|
	res := CBClass new.

	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	commonKeys do: [:key | mSum at: key put: (methodDict at: key sum: other methods at: key)].
	res methods: mSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

cb := ContractBuilder new.!

o := cb class: ContractBuilder.!

m := o method: #class!

m addPrecondition: 1!

!CBClass methodsFor!
invariants
	^invariantSet! !
!CBClass categoriesFor: #invariants!public! !

!CBClass methodsFor!
invariants: invs
	invariantSet := invs.! !
!CBClass categoriesFor: #invariants:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := selfKeys & otherKeys.
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: invariantSet + other invariants.
	^res! !
!CBClass categoriesFor: #sum:!public! !

"16:55:03, 20 czerwca 2015: Image saved"!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res|
	cls := obj class.
	
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

1 !!= 2!

1 \= 2!

1 = 2!

1 = 2 negated!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) class: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [] ]
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) class: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [] ].
	b b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) class: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

cb := ContractBuilder new.
o := cb class: ContractBuilder.
o addInvariant: [:q | q x notNil].
cb class: ContractBuilder!

cb class: ContractBuilder!

cb := ContractBuilder new.
o := cb class: 'wosiaczek'.
o addInvariant: [:q | q x notNil].
cb class: 'wosiaczek'!

cb class: 'wosiaczek'!

chuj := cb class: 'wosiaczek'.!

chuj!

cb := ContractBuilder new.
o := cb class: 'wosiaczek'.
o addInvariant: [:q | q x notNil].
chuj := cb class: 'wosiaczek'.
chuj!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) class: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls class = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  ((cls class) = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  ((cls class) = #Object) negated ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  ((cls class) = #Object) not ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!CBMethod methodsFor!
sum: other
	|res|
	res := CBMethod new.
	res preConditions: (self preConditions union: (other preConditions)).
	res postConditions: (self postConditions union: (other postConditions)).
	^res! !
!CBMethod categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: other methods.
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = #Object) not ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [^(CBClass new)]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = #Object) not ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [CBClass new]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = Object) not ifTrue: [
		res := res sum: (cbcDict at: cls ifAbsent: [CBClass new]).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

"19:25:30, 20 czerwca 2015: Image saved"!

!Instrument class methodsFor!
contract: contr on: obj
	^(Instrument new) ! !
!Instrument class categoriesFor: #contract:on:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument class methodsFor!
new
	^super new! !
!Instrument class categoriesFor: #new!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

p :=ProtoObject new.!

p :=ProtoObject new.!

p :=ProtoObject new.!

p :=ProtoObject new.!

!ContractViolation methodsFor!
isResumable
	^true! !
!ContractViolation categoriesFor: #isResumable!public! !

ContractViolation subclass: #InvariantViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
InvariantViolation guid: (GUID fromString: '{93771876-6E5D-41DA-BBB7-A055B559CD73}')!
InvariantViolation comment: ''!
!InvariantViolation categoriesForClass!Unclassified! !
ContractViolation subclass: #ConditionViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
ConditionViolation guid: (GUID fromString: '{4A410916-2BB2-4B1C-8141-9C242661B547}')!
ConditionViolation comment: ''!
!ConditionViolation categoriesForClass!Unclassified! !
ConditionViolation subclass: #PreconditionViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
PreconditionViolation guid: (GUID fromString: '{4516B15B-74D3-4482-9AD0-2CC07A87CFD5}')!
PreconditionViolation comment: ''!
!PreconditionViolation categoriesForClass!Unclassified! !
ConditionViolation subclass: #PostconditionViolation
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
PostconditionViolation guid: (GUID fromString: '{6347CAA0-DABE-4733-975A-9C95B1C581F8}')!
PostconditionViolation comment: ''!
!PostconditionViolation categoriesForClass!Unclassified! !
Error subclass: #ContractViolation
	instanceVariableNames: 'obj'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ContractViolation methodsFor!
object: aObj
	obj := aObj.
	! !
!ContractViolation categoriesFor: #object:!public! !

!ContractViolation methodsFor!
object
	^obj! !
!ContractViolation categoriesFor: #object!public! !

Error subclass: #ContractViolation
	instanceVariableNames: 'obj cond'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ContractViolation methodsFor!
condition: aCond
	cond := aCond.! !
!ContractViolation categoriesFor: #condition:!public! !

!ContractViolation methodsFor!
condition
	^cond! !
!ContractViolation categoriesFor: #condition!public! !

ContractViolation subclass: #ConditionViolation
	instanceVariableNames: 'meth'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!ConditionViolation methodsFor!
method: aMeth
	meth := aMeth.! !
!ConditionViolation categoriesFor: #method:!public! !

!ConditionViolation methodsFor!
method
	^meth! !
!ConditionViolation categoriesFor: #method!public! !

"20:45:30, 20 czerwca 2015: Image saved"!

ProtoObject subclass: #Instrument
	instanceVariableNames: 'contr object'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

!Instrument class methodsFor!
contract: aContr on: aObj
	^super new contract: aContr object: aObj! !
!Instrument class categoriesFor: #contract:on:!public! !

ProtoObject subclass: #Instrument
	instanceVariableNames: 'contr obj'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

Instrument class removeSelector: #new ifAbsent: []!

!Instrument methodsFor!
contract: aContr
	contr := aContr.! !
!Instrument categoriesFor: #contract:!public! !

!Instrument methodsFor!
object: aObj
	obj := aObj.! !
!Instrument categoriesFor: #object:!public! !

!Instrument methodsFor!
object: aObj
	obj := aObj.! !
!Instrument categoriesFor: #object:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = Object) not ifTrue: [
		res := res sum: (self class: cls).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = Object) ifFalse: [
		res := res sum: (self class: cls).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

!ContractBuilder methodsFor!
contractFor: obj
	|cls res b|
	cls := obj class.
	res := (CBClass new) c: cls.
	b := [:jmp |  (cls = Object) ifFalse: [
		res := res sum: (self class: cls).
		cls := cls superclass.
		jmp value: jmp] ].
	b value: b.
	^res
	! !
!ContractBuilder categoriesFor: #contractFor:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: bc!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: ao.!

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: (other methods).
	selfKeys := methodDict keys.
	otherKeys := other methods keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: (other methods).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: ao.!

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: ((other methods) collection).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: ao.!

cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
bc := A subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
ao := bc new.

((cb class: ac) method: 'wosiakowa')
	addPrecondition: [:qac | qac x notNil].
((cb class: ac) method: 'rozmaita')
	addPrecondition: [:qac | qac x notNil].
((cb class: bc) method: 'rozmaita')
	addPrecondition: [:qbc | qbc x notNil].

cb contractFor: ao.!

"21:30:17, 20 czerwca 2015: Image saved"!

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants;
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [InvariantViolation new object: obj condition: inv; signal.]
	].
	msg forwardTo: obj
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(InvariantViolation new) object: obj condition: inv; signal.]
	].
	msg forwardTo: obj
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(InvariantViolation new) object: obj condition: inv; signal.]
	].
	msg forwardTo: obj.
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument class methodsFor!
contract: aContr on: aObj
	^(super new) contract: aContr object: aObj! !
!Instrument class categoriesFor: #contract:on:!public! !

Instrument removeSelector: #object: ifAbsent: []!

!Instrument methodsFor!
contract: aContr object: aObj
	contr := aContr.
	obj := aObj.! !
!Instrument categoriesFor: #contract:object:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	msg forwardTo: obj.
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

Instrument removeSelector: #contract: ifAbsent: []!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [^(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [^(((PreconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [^(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [^(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [^((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [(((PreconditionViolation new) object: obj) condition: preCond) method: meth; signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [((InvariantViolation new) object: obj) condition: inv; signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [(((PostconditionViolation new) object: obj) condition: postCond) method: meth; signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!Instrument methodsFor!
doesNotUnderstand: msg
	|invariants meth args res|
	invariants := contr invariants.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal]
	].
	meth := msg selector.
	args := msg arguments.
	((contr method: meth) preConditions) do: [:preCond |
		(preCond valueWithArguments: args) ifFalse:  [((((PreconditionViolation new) object: obj) condition: preCond) method: meth) signal.]
	].
	res := msg forwardTo: obj.
	invariants do: [:inv | 
		(inv value: obj) ifFalse: [(((InvariantViolation new) object: obj) condition: inv) signal.]
	].
	((contr method: meth) postConditions) do: [:postCond |
		(postCond valueWithArguments: args) ifFalse:  [((((PostconditionViolation new) object: obj) condition: postCond) method: meth) signal.]
	].
	^res
	
	! !
!Instrument categoriesFor: #doesNotUnderstand:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

cb!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

cbo := cb contractFor: bo.!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

|s b|!

s := Set new.!

b := [:q | q x isNull].!

s add: b.!

s remove: b.!

s remove: b.!

|s b|
s := Set new.
b := [:q | q x isNull].
s add: b.
s remove: b.!

|s b|
s := Set new.
b := [:q | q x isNull].
s add: b.
s remove: b.!

|s b|
s := Set new.
b := [:q | q x isNull].
s add: b.
s remove: b.!

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: (invariantSet union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: ((invariantSet copy) union: other invariants).
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: ((invariantSet copy) union: ((other invariants) copy)).
	^res! !
!CBClass categoriesFor: #sum:!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	res invariants: ((invariantSet copy) union: ((other invariants) copy)).
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

!CBClass methodsFor!
sum: other
	|res mSum selfKeys otherKeys commonKeys iSum|
	res := CBClass new.
	mSum := methodDict copy.
	mSum addAll: ((other methods) associations).
	selfKeys := methodDict keys.
	otherKeys := (other methods) keys.
	commonKeys := (selfKeys intersection: otherKeys).
	commonKeys do: [:key | mSum at: key put: ((methodDict at: key) sum: (other methods at: key))].
	res methods: mSum.
	iSum := invariantSet copy.
	iSum addAll: (other invariants).
	res invariants: iSum.
	^res! !
!CBClass categoriesFor: #sum:!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

!B methodsFor!
y ^y! !
!B categoriesFor: #y!public! !

| cb ac bc ao bo cao cbo iao ibo i1 i2 i3 i4 i5 t |
cb := ContractBuilder new.
ac := Object subclass: #A instanceVariableNames: 'x' classVariableNames: '' poolDictionaries: ''.
ao := ac new.
i1 := [:q | q x notNil].
(cb class: ac) addInvariant: i1.
ac compile: 'x ^x'.
cao := cb contractFor: ao.
iao := Instrument contract: cao on: ao.
t := [:b :h || z |
    z := Dictionary
        with: InvariantViolation -> Set new
        with: PreconditionViolation -> Set new
        with: PostconditionViolation -> Set new.
    b on: ContractViolation do: [:e | (z at: e class) add: e. e resume].
    h value: (z at: InvariantViolation) value: (z at: PreconditionViolation) value: (z at: PostconditionViolation)].
t value: [self assert: [iao x isNil]] value:
    [:inv :pre :post |
    self assert: [inv size = 2].
    inv do: [:e | self assert: [e object == ao and: [e condition == i1]]]].
ac compile: 'x: a x := a. ^x'.
t value: [self assert: [(iao x: 1) = 1]] value:
    [:inv :pre :post |
    self assert: [inv size = 1]].
cao removeInvariant: i1.
ao x: nil.
t value: [self assert: [(Instrument contract: cao on: ao) x isNil]] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
t value: [(Instrument contract: (cb contractFor: ao) on: ao) x] value:
    [:inv :pre :post |
    self assert: [inv size = 2]].
bc := ac subclass: #B instanceVariableNames: 'y' classVariableNames: '' poolDictionaries: ''.
bo := bc new.
bc compile: 'y ^y'.
i2 := [:q | q y isNil].
i3 := [:q | 1 + 2 * 3 = 9].
(cb class: bc)
    addInvariant: i2;
    removeInvariant: i1;
    addInvariant: i3.
cbo := cb contractFor: bo.
t value: [(Instrument contract: cbo on: bo) y] value:
    [:inv :pre :post |
    self assert: [inv isEmpty]].
i4 := [:q :a | a = 5].
i5 := [:q :a :w | a * a = w].
((cb class: bc) method: #f:)
    addPrecondition: i4;
    addPostcondition: i5.
bc compile: 'f: a ^a * a * a'.
ibo := Instrument contract: (cb contractFor: bo) on: bo.
t value: [ibo f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre size = 1].
    self assert: [post size = 1].
    self assert:
        [|w|
        w := pre anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i4]]].
    self assert:
        [|w|
        w := post anyOne.
        w object == bo and:
            [w method == #f: and:
                [w condition == i5]]]].
t value: [(Instrument contract: cbo on: bo) f: 4] value:
    [:inv :pre :post |
    self assert: [inv isEmpty].
    self assert: [pre isEmpty].
    self assert: [post isEmpty]]!

!A methodsFor!
x ^x! !
!A categoriesFor: #x!public! !

!A methodsFor!
x: a x := a. ^x! !
!A categoriesFor: #x:!public! !

"23:58:16, 20 czerwca 2015: Image saved"!
